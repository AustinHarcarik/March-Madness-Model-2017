---
title: "March Madness Model Report"
author: "Austin Harcarik"
date: "3/15/2017"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Introduction:  
Rather than filling out my bracket with my gut this year, I decided to make a model and see how it does. The goal of this study is to model the score difference of any game (team a - team b) using data from the 2016-2017 NCAA basketball season. The data used in this study is from a Kaggle competition. There are about 5400 games and 351 teams in the dataset. Because of my strange obsession with Andrew Gelman, I had to make a bayesian hierarchical model. 

Model:  
This model has two main assumptions:  
- each team has some 'true talent level'  
- each team has some 'true home court advantage'   

The score differential in game $i$, denoted as $y_i$ is modeled as a normal distribution:  
$y_i ~ N(a_{home} - a_{away} + b_{home}, \sigma_y)$  
where $a_{home}$ and $a_{away}$ are the true talent levels of the home and away teams, respectively, and $b_{home}$ is the home court advantage for the home team. I assume a hierarchical structure for both the true talents and true home court advantages:  
$a_{home}, a_{away} ~ N(0, \tau_a)$  
$\tau_a ~ Unif(0, 12)$  
$b_{home} ~ N(0, \tau_b)$  
$\tau_b ~ Unif(0, 5)$  
$\sigma_y ~ Unif(0, 25)$  

I tried to stick with noninformative priors, but I did limit the parameter space pretty significantly. I believe this to be justified since we have a pretty good idea of how basketball scores are distributed. Moreover, we expect the home court advantage distribution from which each team's home court advantage is drawn to be noticeably less variable than the true talent distribution. 

Because about 10% of all games are played on a neutral court, I only included $b_{home}$ for games in which the home team was actually on its home court. Otherwise, this parameter is zero'd out. 

```{r cleaning_and_munging, warning=FALSE, message=FALSE}
### Cleaning and Munging Data ### 

# load libraries
library(plyr)
library(dplyr)
library(rstan)

# read in data (from Kaggle)
mydata <- read.csv('/users/austinharcarik/Desktop/March_Madness_Data/RegularSeasonCompactResults.csv')
teams <- read.csv('/users/austinharcarik/Desktop/March_Madness_Data/Teams.csv')
mm <- c();

# filter to 2017
mydata <- mydata %>%
  filter(Season == 2017)

# functions to map home and away teams 
map_home <- function(x) {
  home_team <- x[3]
  if (x[7] == 'H') {
    home_team <- x[3]
  }
  if (x[7] == 'A') {
    home_team <- x[5]
  }
  return(as.numeric(home_team))
}
map_away <- function(x) {
  away_team <- x[5]
  if (x[7] == 'H') {
    away_team <- x[5]
  }
  if (x[7] == 'A') {
    away_team <- x[3]
  }
  return(as.numeric(away_team))
}
is_home <- function(x) {
  if (x[7] != 'N') {
    home <- 1
  } else {
    home <- 0
  }
  return(home)
}

# data cleaning 
mydata$team_1 <- apply(X = mydata, FUN = map_home, MARGIN=1)
mydata$team_2 <- apply(X = mydata, FUN = map_away, MARGIN=1)
mydata$is_home <- apply(X = mydata, FUN = is_home, MARGIN=1)
idxs <- which(mydata$Wloc == 'A')
mydata$diff <- mydata$Wscore - mydata$Lscore
mydata[idxs,12] <- mydata[idxs,12] * -1
ids <- sort(unique(mydata$team_1))
new_ids <- 1:length(ids)
mydata$team_1 <- mapvalues(mydata$team_1, from=ids, to=new_ids)
mydata$team_2 <- mapvalues(mydata$team_2, from=ids, to=new_ids)
mydata <- mydata[,c(9:12)]

# create list 
mm$team1 <- mydata$team_1
mm$team2 <- mydata$team_2
mm$is_home <- mydata$is_home
mm$score_diff <- mydata$diff
mm$nteams <- length(unique(mydata$team_1))
mm$ngames <- nrow(mydata)
saveRDS(mm, 'mm_data.rds')

head(mydata)
```

```{r model fitting, warning=FALSE, message=FALSE}
### fitting the model ###

# stan code 
write(x="
      data {
      int nteams; // number of teams 
      int ngames; // number of games
      int<lower=1, upper=nteams> team1[ngames]; // team 1 ID (1, ..., 351)
      int<lower=1, upper=nteams> team2[ngames]; // team 2 ID (1, ..., 351)
      vector[ngames] is_home; // binary variable for home court advantage 
      vector[ngames] score_diff; // team 1 points - team 2 points 
      }
      
      parameters {
      real<lower=0> tau_a; // talent level variation hyperparameter
      real<lower=0> tau_b; // home court advantage variation hyperparameter
      real<lower=0> sigma_y; // score difference variation 
      vector[nteams] a; // team talent levels 
      vector[nteams] b; // team home court advantages
      }
      
      model {
      tau_a ~ uniform(0,12);
      tau_b ~ uniform(0,5);
      sigma_y ~ uniform(0,25);
      a ~ normal(0,tau_a);
      b ~ normal(0,tau_b);
      for (i in 1:ngames) {
      if (is_home[i] == 1) {
      score_diff[i] ~ normal(a[team1[i]]-a[team2[i]] + b[team1[i]],sigma_y);
      } else {
      score_diff[i] ~ normal(a[team1[i]]-a[team2[i]],sigma_y);
      }
      } 
      } 
      
      ", 
      file='mm_model_2.stan')

# fit the model 
mm <- readRDS("mm_data.rds")
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit <- stan(file = 'mm_model_2.stan', 
            data = mm, 
            iter = 2000, 
            chains = 4)

# examine fit
options(max.print=100)
print(fit, digits=1)
```

```{r parameter_results}
# extract parameters 
sims <- extract(fit)
a_sims <- sims$a
a <- colMeans(a_sims)
b_sims <- sims$b
b <- colMeans(b_sims)
sigma_y_sims <- sims$sigma_y
sigma_y <- mean(sigma_y_sims)

# create final dataframe
results <- data.frame(ids, new_ids, a, b)
names(results) <- c('Team_Id', 'Team_Num', 'True_Talent', 'Home_Advantage')
final_results <- inner_join(results, teams, by='Team_Id')

# who are the best teams? 
final_results <- final_results %>%
  arrange(desc(True_Talent))
head(final_results, 10)

# who has the best home court advantage?
final_results <- final_results %>%
  arrange(desc(Home_Advantage))
head(final_results, 10)

# function to make probabilistic predictions
predict_matchup <- function(high_seed_team, low_seed_team) {
  first_team_idx <- which(final_results$Team_Name == high_seed_team)
  second_team_idx <- which(final_results$Team_Name == low_seed_team)
  first_team_talent <- final_results[first_team_idx, 3]
  second_team_talent <- final_results[second_team_idx, 3]
  diff <- first_team_talent - second_team_talent
  prob <- 1 - pnorm(0, mean=diff, sd=sigma_y)
  cat('probability that', high_seed_team, 'beats', low_seed_team, ':', prob)
}

predict_matchup("Duke", "Troy")
predict_matchup("Arkansas", "Seton Hall")
predict_matchup("Notre Dame", "Princeton")
```

Vallidation:  
I will now make predictions on this season's data and look at the residuals. 
```{r validation}
# function to predict score differential 
predict_score_diff <- function(x) {
  team_1 <- x[1]
  team_2 <- x[2]
  team_1_idx <- which(final_results$Team_Num == team_1)
  team_2_idx <- which(final_results$Team_Num == team_2)
  team_1_talent <- final_results[team_1_idx, 3]
  team_2_talent <- final_results[team_2_idx, 3]
  team_1_home_adv <- final_results[team_1_idx, 4]
  diff <- team_1_talent - team_2_talent
  if (x[3] == 1) {
    diff <- team_1_talent - team_2_talent + team_1_home_adv
  }
  return(diff)
}

mydata$preds <- apply(X=mydata, FUN=predict_score_diff, MARGIN=1)
mydata$residual <- mydata$diff - mydata$preds

# examine residuals 
p1 <- ggplot(mydata, aes(residual)) 
p1 + geom_histogram(bandwidth=5, fill='red')
p2 <- ggplot(mydata, aes(preds, residual))
p2 + geom_point() + geom_abline(slope=0, intercept=0, color='red')
rmse <- sqrt(mean(mydata$residual^2))
cat('Root Mean Squared Error:', rmse)
```





